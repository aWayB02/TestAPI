# Архитектура приложения To-Do List

## Общая архитектура

Для реализации проекта используется архитектура MVC (Model-View-Controller) с элементами Clean Architecture для обеспечения тестируемости и разделения ответственности.

```
mermaid
graph TD
    A[Клиент] --> B[API Layer]
    B --> C[Service Layer]
    C --> D[Data Access Layer]
    D --> E[SQLite Database]
    C --> F[Business Logic]
```

## Компоненты архитектуры

### 1. API Layer (Presentation Layer)
- Обработка HTTP запросов
- Валидация входных данных
- Формирование ответов
- Маршрутизация запросов

### 2. Service Layer (Application Layer)
- Бизнес-логика приложения
- Координация между различными компонентами
- Обработка транзакций

### 3. Data Access Layer (Persistence Layer)
- Взаимодействие с базой данных
- ORM или прямые SQL запросы
- Маппинг данных

### 4. Models (Domain Layer)
- Определение структуры данных
- Бизнес-правила
- Валидация данных

## Паттерн MVC

Паттерн MVC (Model-View-Controller) - это архитектурный паттерн проектирования, который разделяет приложение на три основных компонента:

### Компоненты MVC

1. **Model (Модель)** - отвечает за данные и бизнес-логику
2. **View (Представление)** - отвечает за отображение данных пользователю
3. **Controller (Контроллер)** - обрабатывает пользовательский ввод и координирует работу между Model и View

### Подробное объяснение компонентов MVC

#### Model (Модель)

Модель - это основа любого приложения. Она представляет собой структуру данных и бизнес-логику, которая описывает сущности предметной области. В нашем случае моделью является задача (Todo).

**Назначение модели:**
- Определяет структуру данных (поля, типы данных)
- Содержит бизнес-правила и валидацию
- Реализует методы для работы с данными
- Инкапсулирует логику, связанную с обработкой данных

**Пример из нашего проекта:**
В файле `models/todo.py` определен класс `Todo`, который представляет собой задачу. Он содержит:
- Поля: id, title, description, completed, created_at, updated_at
- Методы для работы с данными: to_dict(), from_dict(), mark_completed(), mark_uncompleted(), update()

**Преимущества использования модели:**
- Централизованное определение структуры данных
- Повторное использование кода
- Упрощение поддержки и изменений
- Обеспечение целостности данных

#### View (Представление)

В традиционных веб-приложениях View отвечает за отображение данных пользователю в виде HTML-страниц. Однако в API-проектах, таких как наш To-Do List, представление реализуется в виде JSON-ответов.

**Назначение представления:**
- Формирование ответов в понятном для клиента формате
- Преобразование данных модели в сериализуемый формат
- Обеспечение единообразия в структуре ответов

**Пример из нашего проекта:**
В API слое (`api/todo_api.py`) все ответы формируются в виде JSON с одинаковой структурой:
```json
{
  "status": "success",
  "data": {
    "id": 1,
    "title": "Купить молоко",
    "description": "В магазине Пятерочка",
    "completed": false,
    "created_at": "2026-02-22T10:00:00Z",
    "updated_at": null
  }
}
```

**Преимущества использования представления:**
- Единообразие в формате ответов
- Упрощение обработки данных на стороне клиента
- Возможность централизованного изменения формата ответов

#### Controller (Контроллер)

Контроллер - это посредник между моделью и представлением. Он обрабатывает запросы от клиента, взаимодействует с сервисным слоем и формирует ответы.

**Назначение контроллера:**
- Обработка HTTP запросов
- Валидация входных данных
- Вызов методов сервисного слоя
- Формирование HTTP ответов
- Обработка ошибок

**Пример из нашего проекта:**
В файле `api/todo_api.py` реализованы различные эндпоинты для работы с задачами:
- `GET /api/v1/todos` - получение списка задач
- `POST /api/v1/todos` - создание новой задачи
- `PUT /api/v1/todos/{id}` - обновление задачи
- `DELETE /api/v1/todos/{id}` - удаление задачи

**Преимущества использования контроллера:**
- Четкое разделение ответственности
- Упрощение тестирования
- Повышение переиспользуемости кода

### Реализация MVC в проекте

В проекте To-Do List используется адаптированная версия паттерна MVC:

#### 1. Model (Модель)
Файл: `models/todo.py`

Модель `Todo` представляет собой класс, который:
- Определяет структуру задачи (id, title, description, completed, created_at, updated_at)
- Содержит методы для работы с данными задачи (mark_completed, mark_uncompleted, update)
- Реализует преобразование в/из словаря (to_dict, from_dict)

#### 2. View (Представление)
В данном API-проекте представление реализовано в виде JSON-ответов, которые формируются в API слое.

#### 3. Controller (Контроллер)
Файл: `api/todo_api.py`

Контроллер реализован в виде FastAPI роутера, который:
- Обрабатывает HTTP запросы
- Выполняет валидацию входных данных
- Вызывает методы сервисного слоя
- Формирует HTTP ответы

## Технологии

- **Язык**: Python 3.x
- **Веб-фреймворк**: FastAPI (асинхронный, высокая производительность)
- **База данных**: SQLite (встроенный движок, не требует отдельной установки)
- **ORM**: SQLAlchemy (для удобной работы с БД)
- **Тестирование**: pytest

## Паттерны проектирования

### 1. Repository Pattern (Паттерн репозиторий)

Repository Pattern - это паттерн проектирования, который создает абстракцию между бизнес-логикой и слоем доступа к данным.

**Зачем он нужен:**
- Скрывает детали реализации работы с базой данных
- Позволяет легко менять способ хранения данных (с SQLite на PostgreSQL и т.д.)
- Упрощает тестирование бизнес-логики
- Снижает связность компонентов

**Как он реализован в проекте:**
В проекте репозиторий реализован в файле `repositories/todo_repository.py`. Он предоставляет простые методы для работы с задачами:
- `create()` - создание новой задачи
- `get_by_id()` - получение задачи по ID
- `get_all()` - получение всех задач
- `update()` - обновление задачи
- `delete()` - удаление задачи

Сервис (`services/todo_service.py`) использует репозиторий для работы с данными, не заботясь о деталях их хранения.

**Преимущества Repository Pattern:**
- Упрощение тестирования (можно использовать моки вместо реальной БД)
- Гибкость в выборе хранилища данных
- Централизация логики доступа к данным
- Повышение переиспользуемости кода

### 2. Service Pattern (Паттерн сервис)

Service Pattern - это паттерн проектирования, который инкапсулирует бизнес-логику приложения в отдельные классы-сервисы.

**Зачем он нужен:**
- Собирает всю бизнес-логику в одном месте
- Упрощает тестирование логики
- Повышает переиспользуемость кода
- Снижает связность компонентов

**Как он реализован в проекте:**
В проекте сервис реализован в файле `services/todo_service.py`. Он содержит методы для работы с задачами:
- `create_todo()` - создание задачи с валидацией
- `get_todo()` - получение задачи
- `get_all_todos()` - получение списка задач
- `update_todo()` - обновление задачи с валидацией
- `delete_todo()` - удаление задачи

API слой использует сервис для выполнения операций, не заботясь о деталях реализации.

**Преимущества Service Pattern:**
- Централизация бизнес-логики
- Упрощение тестирования
- Повышение переиспользуемости кода
- Четкое разделение ответственности

### 3. Dependency Injection (Внедрение зависимостей)

Dependency Injection - это паттерн проектирования, при котором объект получает свои зависимости извне, а не создает их сам.

**Зачем он нужен:**
- Упрощает тестирование (можно подставить моки вместо реальных зависимостей)
- Снижает связность компонентов
- Повышает гибкость приложения
- Упрощает конфигурацию приложения

**Как он реализован в проекте:**
В проекте используется через систему зависимостей FastAPI. Когда API endpoint нуждается в сервисе, он получает его через параметры функции:

```python
def get_todo_service(db: Session = Depends(get_db)) -> TodoService:
    return TodoService(db)

@router.get("/{todo_id}")
async def get_todo(todo_id: int, service: TodoService = Depends(get_todo_service)):
    # service автоматически создается и передается в функцию
```

**Преимущества Dependency Injection:**
- Упрощение тестирования
- Снижение связности компонентов
- Повышение гибкости приложения
- Централизованное управление зависимостями

## Примеры взаимодействия компонентов

### Создание новой задачи

1. **Клиент** отправляет POST запрос на `/api/v1/todos` с данными задачи
2. **Controller** (`api/todo_api.py`) принимает запрос и валидирует входные данные
3. **Controller** вызывает метод `create_todo()` у **Service** (`services/todo_service.py`)
4. **Service** проверяет данные (валидация) и создает объект `Todo`
5. **Service** вызывает метод `create()` у **Repository** (`repositories/todo_repository.py`)
6. **Repository** сохраняет задачу в базу данных и возвращает сохраненный объект
7. **Service** возвращает созданный объект контроллеру
8. **Controller** преобразует объект в JSON и отправляет ответ клиенту

### Получение списка задач

1. **Клиент** отправляет GET запрос на `/api/v1/todos`
2. **Controller** (`api/todo_api.py`) принимает запрос
3. **Controller** вызывает метод `get_all_todos()` у **Service** (`services/todo_service.py`)
4. **Service** вызывает метод `get_all()` у **Repository** (`repositories/todo_repository.py`)
5. **Repository** получает список задач из базы данных и преобразует их в объекты `Todo`
6. **Repository** возвращает список объектов сервису
7. **Service** возвращает список контроллеру
8. **Controller** преобразует объекты в JSON и отправляет ответ клиенту

## Преимущества выбранной архитектуры

1. **Тестируемость** - каждый слой может быть протестирован отдельно
   - Модели можно тестировать независимо от базы данных
   - Сервисы можно тестировать с моками репозиториев
   - API можно тестировать с моками сервисов

2. **Расширяемость** - легко добавлять новую функциональность
   - Новые эндпоинты добавляются в API слой
   - Новая бизнес-логика добавляется в Service слой
   - Новые операции с данными добавляются в Repository слой

3. **Поддерживаемость** - четкое разделение ответственности
   - Каждый компонент имеет одну ответственность
   - Изменения в одном слое не влияют на другие слои
   - Легко находить и исправлять ошибки

4. **Гибкость** - возможность замены компонентов без изменения всей системы
   - Можно заменить базу данных без изменения сервисов
   - Можно изменить формат API без изменения бизнес-логики
   - Можно заменить фреймворк без изменения моделей

5. **Масштабируемость** - архитектура позволяет легко масштабировать приложение
   - Можно вынести базу данных на отдельный сервер
   - Можно добавить кэширование
   - Можно разделить приложение на микросервисы

6. **Читаемость и понятность** - структура проекта интуитивно понятна
   - Каждый файл имеет четкое назначение
   - Легко ориентироваться в коде
   - Новые разработчики быстро понимают архитектуру